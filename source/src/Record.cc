  /// \file Record.cc
/*
 *
 * Record.cc source template automatically generated by a class generator
 * Creation date : dim. janv. 17 2016
 *
 * This file is part of xdrstream libraries.
 * 
 * xdrstream is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * xdrstream is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with xdrstream.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "xdrstream/Record.h"
#include "xdrstream/Block.h"
#include "xdrstream/XdrStreamInterface.h"
#include "xdrstream/IODevice.h"

namespace xdrstream
{

Record::Record(XdrStream *pXdrStream, const std::string &name) :
		m_unpack(true),
		m_pXdrStream(pXdrStream),
		m_name(name)
{
	/* nop */
}

//----------------------------------------------------------------------------------------------------

Record::~Record() 
{
	/* nop */
}

//----------------------------------------------------------------------------------------------------

void Record::setUnpack(bool unpack)
{
	m_unpack = unpack;
}

//----------------------------------------------------------------------------------------------------

bool Record::getUnpack() const
{
	return m_unpack;
}

//----------------------------------------------------------------------------------------------------

Status Record::connectBlock(const std::string &blockName)
{
	if( blockName.empty() )
		return XDR_INVALID_PARAMETER;

	if( m_blockMap.find( blockName ) != m_blockMap.end() )
		return XDR_SUCCESS;

	Block *pBlock = m_pXdrStream->getBlock( blockName );

	if( ! pBlock )
		return XDR_BLOCK_NOT_FOUND;

	m_blockMap[ blockName ] = pBlock;

	return XDR_SUCCESS;
}

//----------------------------------------------------------------------------------------------------

Status Record::disconnectBlock(const std::string &blockName)
{
	if( blockName.empty() )
		return XDR_INVALID_PARAMETER;

	BlockMap::iterator findIter = m_blockMap.find( blockName );

	if( findIter == m_blockMap.end() )
		return XDR_SUCCESS;

	m_blockMap.erase( findIter );

	return XDR_SUCCESS;
}

//----------------------------------------------------------------------------------------------------

Status Record::disconnectAllBlocks()
{
	m_blockMap.clear();
	return XDR_SUCCESS;
}

//----------------------------------------------------------------------------------------------------

const XdrStream *Record::getXdrStream() const
{
	return m_pXdrStream;
}

//----------------------------------------------------------------------------------------------------

const std::string &Record::getName() const
{
	return m_name;
}

//----------------------------------------------------------------------------------------------------

Status Record::readRecord(IODevice *pDevice)
{
	if( NULL == pDevice )
		return XDR_INVALID_PARAMETER;

	while( 1 )
	{
		Header blockHeader;

		xdr_size_t sobhPosition = pDevice->getPosition();

		// Read the block header. In case of error, this function is assumed to
		// reset the device pointer to the correct position. Else the position of the
		// device should be just after the block header
		Status status = pDevice->blockHeader( XDR_READ_STREAM , blockHeader );

		// end of file (io device) ?
		if( XDR_TESTBIT( status , XDR_EOF ) )
			break;

		// problem ??
		if( ! XDR_TESTBIT( status , XDR_SUCCESS ) )
			return status;

		// end of block reading if marker is not a block marker
		if( blockHeader.m_marker != blockMarker )
		{
			XDR_STREAM( pDevice->seek(sobhPosition) )
			return XDR_SUCCESS;
		}

		// get the associated block from the xdr stream
		BlockMap::iterator iter = m_blockMap.find( blockHeader.m_name );

		if( iter == m_blockMap.end() )
			return XDR_BLOCK_NOT_FOUND;

		// stream the block of data
		XDR_STREAM( iter->second->stream( XDR_READ_STREAM , pDevice , blockHeader.m_version ) )
	}

	return XDR_SUCCESS;
}

//----------------------------------------------------------------------------------------------------

Status Record::writeRecord(IODevice *pDevice)
{
	if(NULL == pDevice)
		return XDR_INVALID_PARAMETER;

	for(BlockMap::iterator iter = m_blockMap.begin(), endIter = m_blockMap.end() ;
			endIter != iter ; ++iter)
	{
		xdr_size_t startOfBlockHeaderPosition = pDevice->getPosition();

		// fill first pieces of information about the block header
		Header blockHeader;
		blockHeader.m_marker = blockMarker;
		blockHeader.m_version = iter->second->getVersion();
		blockHeader.m_name = iter->first;

		// write the block header with missing information
		XDR_STREAM( pDevice->blockHeader( XDR_WRITE_STREAM , blockHeader ) )

		xdr_size_t startOfBlockPosition = pDevice->getPosition();

		// compute the header length
		blockHeader.m_headerLength = startOfBlockPosition - startOfBlockHeaderPosition;

		// write the data block
		XDR_STREAM( iter->second->stream( XDR_WRITE_STREAM , pDevice , blockHeader.m_version ) )

		xdr_size_t endOfBlockPosition = pDevice->getPosition();

		// set block length
		blockHeader.m_length = endOfBlockPosition - startOfBlockPosition;

		// get back to start of block header position and write
		// the complete header, then get back to current position
		XDR_STREAM( pDevice->seek( startOfBlockHeaderPosition ) )
		XDR_STREAM( pDevice->blockHeader( XDR_WRITE_STREAM , blockHeader ) )
		XDR_STREAM( pDevice->seek( endOfBlockPosition ) )
	}

	return XDR_SUCCESS;
}

} 

