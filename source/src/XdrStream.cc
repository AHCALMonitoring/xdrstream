  /// \file XdrStream.cc
/*
 *
 * XdrStream.cc source template automatically generated by a class generator
 * Creation date : dim. janv. 24 2016
 *
 * This file is part of xdrtstream libraries.
 * 
 * xdrtstream is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * xdrtstream is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with xdrtstream.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "xdrstream/XdrStream.h"
#include "xdrstream/Record.h"
#include "xdrstream/Block.h"
#include "xdrstream/IODevice.h"

namespace xdrstream
{

XdrStream::XdrStream() 
{

}

//----------------------------------------------------------------------------------------------------

XdrStream::~XdrStream() 
{
	for( BlockMap::iterator iter = m_blockMap.begin() ; iter != m_blockMap.end() ; iter = m_blockMap.begin())
	{
		// calling the destructor implies unregistration from the map
		delete iter->second;
	}

	for( RecordMap::iterator iter = m_recordMap.begin() ; iter != m_recordMap.end() ; ++iter)
	{
		delete iter->second;
	}

	m_blockMap.clear();
	m_recordMap.clear();
}

//----------------------------------------------------------------------------------------------------

Status XdrStream::writeRecord(const std::string &recordName, IODevice *pDevice)
{
	if( NULL == pDevice )
		return XDR_INVALID_PARAMETER;

	// device must be opened
	if( ! pDevice->isOpened() )
		return XDR_DEVICE_NOT_OPENED;

	// device must be writable
	if( ! pDevice->isWritable() )
		return XDR_IO_ERROR;

	// find the record before writing anything
	Record *pRecord = this->getRecord(recordName);

	if( ! pRecord )
		return XDR_RECORD_NOT_FOUND;

	// get start of record header position
	xdr_size_t sorhPosition = pDevice->getPosition();

	// Write the record header as a place holder
	// The header will be filled after having written
	// the whole record and setting its total size
	Header recordHeader;
	recordHeader.m_name = recordName;
	recordHeader.m_marker = recordMarker;

	XDR_STREAM( pDevice->recordHeader( XDR_WRITE_STREAM , recordHeader ) )

	xdr_size_t sorPosition = pDevice->getPosition();
	recordHeader.m_headerLength = sorPosition - sorhPosition;

	// write the record
	XDR_STREAM( pRecord->writeRecord(pDevice) )

	// fill the header go back to to header place holder position
	// write it and go back again to end record position
	xdr_size_t eorPosition = pDevice->getPosition();
	recordHeader.m_length = eorPosition - sorPosition;

	XDR_STREAM( pDevice->seek(sorhPosition) )
	XDR_STREAM( pDevice->recordHeader( XDR_WRITE_STREAM , recordHeader ) )
	XDR_STREAM( pDevice->seek(eorPosition) )

	return XDR_SUCCESS;
}

//----------------------------------------------------------------------------------------------------

Status XdrStream::readRecord(Record *&pRecord, IODevice *pDevice)
{
	pRecord = NULL;

	if( NULL == pDevice )
		return XDR_INVALID_PARAMETER;

	// device must be opened
	if( ! pDevice->isOpened() )
		return XDR_DEVICE_NOT_OPENED;

	// device must be readable
	if( ! pDevice->isReadable() )
		return XDR_IO_ERROR;

	// get start of record position
	xdr_size_t sorPosition = pDevice->getPosition();

	// read record header
	Header recordHeader;
	XDR_STREAM( pDevice->recordHeader( XDR_READ_STREAM , recordHeader ) )

	// check for record marker
	if(recordHeader.m_marker != recordMarker)
	{
		uint64_t eorPosition = sorPosition + recordHeader.m_length;
		pDevice->seek(eorPosition);

		return XDR_UNEXPECTED_MARKER;
	}

	pRecord = this->getRecord(recordHeader.m_name);

	if( ! pRecord )
		return XDR_RECORD_NOT_FOUND;

	// read the record
	XDR_STREAM( pRecord->readRecord(pDevice) )

	// and perform pointer relocation
	XDR_STREAM( pDevice->performPointerMapping() )

	return XDR_SUCCESS;
}

//----------------------------------------------------------------------------------------------------

Status XdrStream::skipNextRecord(IODevice *pDevice)
{
	if( NULL == pDevice )
		return XDR_INVALID_PARAMETER;

	// device must be opened
	if( ! pDevice->isOpened() )
		return XDR_DEVICE_NOT_OPENED;

	// device must be readable
	if( ! pDevice->isReadable() )
		return XDR_IO_ERROR;

	// get start of record position
	xdr_size_t sorPosition = pDevice->getPosition();

	// read record header
	Header recordHeader;
	XDR_STREAM( pDevice->recordHeader( XDR_READ_STREAM , recordHeader ) )

	// check for record marker
	if(recordHeader.m_marker != recordMarker)
		return pDevice->seek(sorPosition);

	uint64_t eorPosition = sorPosition + recordHeader.m_length;

	return pDevice->seek(eorPosition);
}

//----------------------------------------------------------------------------------------------------

Record *XdrStream::createRecord(const std::string &recordName)
{
	RecordMap::iterator findIter = m_recordMap.find( recordName );

	if( findIter != m_recordMap.end() )
		return findIter->second;

	Record *pRecord = new Record(this, recordName);
	m_recordMap[ recordName ] = pRecord;

	return pRecord;
}

//----------------------------------------------------------------------------------------------------

Record *XdrStream::getRecord(const std::string &recordName) const
{
	RecordMap::const_iterator findIter = m_recordMap.find( recordName );

	if( findIter != m_recordMap.end() )
		return findIter->second;

	return NULL;
}

//----------------------------------------------------------------------------------------------------

Status XdrStream::removeRecord(Record *pRecord)
{
	if( pRecord->getXdrStream() != this )
		return XDR_INVALID_PARAMETER;

	return this->removeRecord( pRecord->getName() );
}

//----------------------------------------------------------------------------------------------------

Status XdrStream::removeRecord(const std::string &recordName)
{
	RecordMap::iterator findIter = m_recordMap.find( recordName );

	if( findIter == m_recordMap.end() )
		return XDR_RECORD_NOT_FOUND;

	delete findIter->second;
	m_recordMap.erase( findIter );

	return XDR_SUCCESS;
}

//----------------------------------------------------------------------------------------------------

Block *XdrStream::getBlock(const std::string &blockName) const
{
	BlockMap::const_iterator findIter = m_blockMap.find( blockName );

	if( findIter != m_blockMap.end() )
		return findIter->second;

	return NULL;
}

//----------------------------------------------------------------------------------------------------

Status XdrStream::addBlock(Block *pBlock)
{
	BlockMap::iterator findIter = m_blockMap.find( pBlock->getName() );

	if( findIter != m_blockMap.end() )
	{
		delete pBlock;
		return XDR_ALREADY_PRESENT;
	}

	m_blockMap[ pBlock->getName() ] = pBlock;

	return XDR_SUCCESS;
}

//----------------------------------------------------------------------------------------------------

Status XdrStream::removeBlock(Block *pBlock)
{
	BlockMap::iterator findIter = m_blockMap.find( pBlock->getName() );

	if( findIter == m_blockMap.end() )
		return XDR_BLOCK_NOT_FOUND;

	// no delete since this method is called from block destructor
	m_blockMap.erase( findIter );

	return XDR_SUCCESS;
}

} 

